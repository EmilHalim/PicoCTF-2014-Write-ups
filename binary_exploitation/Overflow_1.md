## Overflow 1 - 50 (Binary Exploitation) ##
#### Writeup by NielsKornerup

Created: 2014-11-10 22:19:58

Last modified: [2014-11-11 00:14:40](https://github.com/Oksisane/PicoCTF-2014-Writeups/commits/master/binary_exploitation/Overflow_1.md)


### Problem ###

This problem has a buffer overflow vulnerability! Can you get a shell, then use that shell to read flag.txt? You can solve this problem interactively [here](https://picoctf.com/problem-static/binary/Overflow1/overflow1.html#1), and the source can be found [here](https://picoctf.com/problem-static/binary/Overflow1/overflow1.c).

### Hint ###

Can you overflow into the 'secret' variable?

## Answer ##

### Overview ###

A buffer overflow error is when a program expects input of a particular size and does nothing to protect against larger input 'overflowing' into the program's memory, altering other parts of the program. In this problem, the goal is to give an input that will change the value of secret to 0xc0deface.

### Details ###

If you open the [interactive problem solver](https://picoctf.com/problem-static/binary/Overflow1/overflow1.html#1), there is a brief description of how a buffer overflow works. Scroll to the bottom of the page to find an interactive problem solver, which displays the stack for the program. If you look carefully, you will see that the memory address for secret is right above the buffer on the stack. To solve this problem, you must provide an input that will overflow into secret and change it to the desired value, 0xc0deface. The interactive problem solver makes this easier, as it allows us to see the effects of our input on the stack.

Before we can take advantage of a buffer overflow, we need to fill the buffer with values. Fortunately, this problem does not care what is entered into the buffer, so you can just fill it with zeros. This makes our input look like 0000000000000000. Notice that as you enter zeros, the buffer fills from right to left. Now that we have filled the buffer, it is time to modify the value of secret. Now we face a problem: secret is an eight digit hex number while it only takes up for slots in the program's memory. If you followed my example and entered 0's into the buffer, you would notice that the resulting values in the buffer were 30's. This is because this program's memory is stored using character values. To find the correct characters, you can look them up on a table, or you can use \x followed by the two digit code that you desire. The \x says that you want the value of the character with that code. Lets try using this to change the value of secret to 0xc0deface, giving us 0000000000000000\xc0\xde\xfa\xce. If you run this, the program will return "The secret is cefadec0," which is the value we want backwards, because the buffer fills from right to left while secret is read from left to right. If we reverse the order of our characters, we get 0000000000000000\xce\xfa\xde\xc0, which will give us the shell! Now that we have the shell, all we need to do is open flag.txt with something like nano, and we should get the flag.


### Flag ###

    ooh_so_critical
